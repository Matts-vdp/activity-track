"use strict";(self.webpackChunkactivity_track=self.webpackChunkactivity_track||[]).push([[364],{364:(F,v,b)=>{b.r(v),b.d(v,{FilesystemWeb:()=>q});var a=b(861),R=b(423);function x(h){const p=h.split("/").filter(t=>"."!==t),r=[];return p.forEach(t=>{".."===t&&r.length>0&&".."!==r[r.length-1]?r.pop():r.push(t)}),r.join("/")}let q=(()=>{class h extends R.Uw{constructor(){super(...arguments),this.DB_VERSION=1,this.DB_NAME="Disc",this._writeCmds=["add","put","delete"]}initDb(){var r=this;return(0,a.Z)(function*(){if(void 0!==r._db)return r._db;if(!("indexedDB"in window))throw r.unavailable("This browser doesn't support IndexedDB");return new Promise((t,i)=>{const e=indexedDB.open(r.DB_NAME,r.DB_VERSION);e.onupgradeneeded=h.doUpgrade,e.onsuccess=()=>{r._db=e.result,t(e.result)},e.onerror=()=>i(e.error),e.onblocked=()=>{console.warn("db blocked")}})})()}static doUpgrade(r){const i=r.target.result;i.objectStoreNames.contains("FileStorage")&&i.deleteObjectStore("FileStorage"),i.createObjectStore("FileStorage",{keyPath:"path"}).createIndex("by_folder","folder")}dbRequest(r,t){var i=this;return(0,a.Z)(function*(){const e=-1!==i._writeCmds.indexOf(r)?"readwrite":"readonly";return i.initDb().then(n=>new Promise((o,s)=>{const c=n.transaction(["FileStorage"],e).objectStore("FileStorage")[r](...t);c.onsuccess=()=>o(c.result),c.onerror=()=>s(c.error)}))})()}dbIndexRequest(r,t,i){var e=this;return(0,a.Z)(function*(){const n=-1!==e._writeCmds.indexOf(t)?"readwrite":"readonly";return e.initDb().then(o=>new Promise((s,d)=>{const l=o.transaction(["FileStorage"],n).objectStore("FileStorage").index(r)[t](...i);l.onsuccess=()=>s(l.result),l.onerror=()=>d(l.error)}))})()}getPath(r,t){const i=void 0!==t?t.replace(/^[/]+|[/]+$/g,""):"";let e="";return void 0!==r&&(e+="/"+r),""!==t&&(e+="/"+i),e}clear(){var r=this;return(0,a.Z)(function*(){(yield r.initDb()).transaction(["FileStorage"],"readwrite").objectStore("FileStorage").clear()})()}readFile(r){var t=this;return(0,a.Z)(function*(){const i=t.getPath(r.directory,r.path),e=yield t.dbRequest("get",[i]);if(void 0===e)throw Error("File does not exist.");return{data:e.content?e.content:""}})()}writeFile(r){var t=this;return(0,a.Z)(function*(){const i=t.getPath(r.directory,r.path),e=r.data,n=r.recursive,o=yield t.dbRequest("get",[i]);if(o&&"directory"===o.type)throw Error("The supplied path is a directory.");const s=r.encoding,d=i.substr(0,i.lastIndexOf("/"));if(void 0===(yield t.dbRequest("get",[d]))){const l=d.indexOf("/",1);if(-1!==l){const m=d.substr(l);yield t.mkdir({path:m,directory:r.directory,recursive:n})}}const c=Date.now(),u={path:i,folder:d,type:"file",size:e.length,ctime:c,mtime:c,content:!s&&e.indexOf(",")>=0?e.split(",")[1]:e};return yield t.dbRequest("put",[u]),{uri:u.path}})()}appendFile(r){var t=this;return(0,a.Z)(function*(){const i=t.getPath(r.directory,r.path);let e=r.data;const n=i.substr(0,i.lastIndexOf("/")),o=Date.now();let s=o;const d=yield t.dbRequest("get",[i]);if(d&&"directory"===d.type)throw Error("The supplied path is a directory.");if(void 0===(yield t.dbRequest("get",[n]))){const u=n.indexOf("/",1);if(-1!==u){const l=n.substr(u);yield t.mkdir({path:l,directory:r.directory,recursive:!0})}}void 0!==d&&(e=d.content+e,s=d.ctime);const c={path:i,folder:n,type:"file",size:e.length,ctime:s,mtime:o,content:e};yield t.dbRequest("put",[c])})()}deleteFile(r){var t=this;return(0,a.Z)(function*(){const i=t.getPath(r.directory,r.path);if(void 0===(yield t.dbRequest("get",[i])))throw Error("File does not exist.");if(0!==(yield t.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(i)])).length)throw Error("Folder is not empty.");yield t.dbRequest("delete",[i])})()}mkdir(r){var t=this;return(0,a.Z)(function*(){const i=t.getPath(r.directory,r.path),e=r.recursive,n=i.substr(0,i.lastIndexOf("/")),o=(i.match(/\//g)||[]).length,s=yield t.dbRequest("get",[n]),d=yield t.dbRequest("get",[i]);if(1===o)throw Error("Cannot create Root directory");if(void 0!==d)throw Error("Current directory does already exist.");if(!e&&2!==o&&void 0===s)throw Error("Parent directory must exist");if(e&&2!==o&&void 0===s){const u=n.substr(n.indexOf("/",1));yield t.mkdir({path:u,directory:r.directory,recursive:e})}const y=Date.now(),c={path:i,folder:n,type:"directory",size:0,ctime:y,mtime:y};yield t.dbRequest("put",[c])})()}rmdir(r){var t=this;return(0,a.Z)(function*(){const{path:i,directory:e,recursive:n}=r,o=t.getPath(e,i),s=yield t.dbRequest("get",[o]);if(void 0===s)throw Error("Folder does not exist.");if("directory"!==s.type)throw Error("Requested path is not a directory");const d=yield t.readdir({path:i,directory:e});if(0!==d.files.length&&!n)throw Error("Folder is not empty");for(const y of d.files){const c=`${i}/${y}`;"file"===(yield t.stat({path:c,directory:e})).type?yield t.deleteFile({path:c,directory:e}):yield t.rmdir({path:c,directory:e,recursive:n})}yield t.dbRequest("delete",[o])})()}readdir(r){var t=this;return(0,a.Z)(function*(){const i=t.getPath(r.directory,r.path),e=yield t.dbRequest("get",[i]);if(""!==r.path&&void 0===e)throw Error("Folder does not exist.");return{files:(yield t.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(i)])).map(s=>s.substring(i.length+1))}})()}getUri(r){var t=this;return(0,a.Z)(function*(){const i=t.getPath(r.directory,r.path);let e=yield t.dbRequest("get",[i]);return void 0===e&&(e=yield t.dbRequest("get",[i+"/"])),{uri:(null==e?void 0:e.path)||i}})()}stat(r){var t=this;return(0,a.Z)(function*(){const i=t.getPath(r.directory,r.path);let e=yield t.dbRequest("get",[i]);if(void 0===e&&(e=yield t.dbRequest("get",[i+"/"])),void 0===e)throw Error("Entry does not exist.");return{type:e.type,size:e.size,ctime:e.ctime,mtime:e.mtime,uri:e.path}})()}rename(r){var t=this;return(0,a.Z)(function*(){return t._copy(r,!0)})()}copy(r){var t=this;return(0,a.Z)(function*(){return t._copy(r,!1)})()}requestPermissions(){return(0,a.Z)(function*(){return{publicStorage:"granted"}})()}checkPermissions(){return(0,a.Z)(function*(){return{publicStorage:"granted"}})()}_copy(r,t=!1){var i=this;return(0,a.Z)(function*(){let{toDirectory:e}=r;const{to:n,from:o,directory:s}=r;if(!n||!o)throw Error("Both to and from must be provided");e||(e=s);const d=i.getPath(s,o),y=i.getPath(e,n);if(d===y)return;if(function D(h,p){h=x(h),p=x(p);const r=h.split("/"),t=p.split("/");return h!==p&&r.every((i,e)=>i===t[e])}(d,y))throw Error("To path cannot contain the from path");let c;try{c=yield i.stat({path:n,directory:e})}catch(g){const f=n.split("/");f.pop();const _=f.join("/");if(f.length>0&&"directory"!==(yield i.stat({path:_,directory:e})).type)throw new Error("Parent directory of the to path is a file")}if(c&&"directory"===c.type)throw new Error("Cannot overwrite a directory with a file");const u=yield i.stat({path:o,directory:s}),l=function(){var g=(0,a.Z)(function*(f,_,w){const E=i.getPath(e,f),P=yield i.dbRequest("get",[E]);P.ctime=_,P.mtime=w,yield i.dbRequest("put",[P])});return function(_,w,E){return g.apply(this,arguments)}}(),m=u.ctime?u.ctime:Date.now();switch(u.type){case"file":{const g=yield i.readFile({path:o,directory:s});return t&&(yield i.deleteFile({path:o,directory:s})),yield i.writeFile({path:n,directory:e,data:g.data}),void(t&&(yield l(n,m,u.mtime)))}case"directory":{if(c)throw Error("Cannot move a directory over an existing object");try{yield i.mkdir({path:n,directory:e,recursive:!1}),t&&(yield l(n,m,u.mtime))}catch(f){}const g=(yield i.readdir({path:o,directory:s})).files;for(const f of g)yield i._copy({from:`${o}/${f}`,to:`${n}/${f}`,directory:s,toDirectory:e},t);t&&(yield i.rmdir({path:o,directory:s}))}}})()}}return h._debug=!0,h})()}}]);